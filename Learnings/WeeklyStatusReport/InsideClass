The SEFP class has been a delight to attend since day one. Here are some of my learnings over the course of past few weeks.

Week-1
-> Case study of Pokemon Go – an augmented reality app that took the world by storm due to its high level of interactivity and playfulness. 
-> Extending augmented reality and location based features to new applications that can solve major problems in our daily lives.
-> Kano model and its three categories – dissatisfiers, satisfiers and delighters.
-> Identifying these three areas in current apps and formulating them to suggest improvements.

Week-2
-> The importance of quality in software development – how instrumental quality is to the success of a software and how it decides its sustenance in the market.
-> Brainstormed on some potential project ideas and discussed it with Sridhar sir and peers.
-> Collaborative learning and its advantages.

Week-3
-> Difference between professional and unprofessional work done.
-> The importance of being equipped with the latest tools and technologies.
-> Characteristics of software.
-> Software engineering is an inter-disciplinary field. An amalgamation of art, science, craft, creativity. 
-> Origins of Software Engineering – NATO and the coinage of the term 'software engineering'. 
-> Djikstra's diary entries, his views on Software Engineering.
-> Basic principles used in software engineering – Abstraction, Decomposition, Modularity. 

Week-4
-> Life cycles of software and comparing these life cycles to those of humans.
-> Influential factors in software life cycles - people, tools, processes and products.
-> The importance of 'requirement engineering' - how critical it is to the formation of a product.
-> Every task done or decision taken must have a 'rationale' with it as an essential component. RATIONALE = THE WHY.
-> Tried to list down the requirements of stakeholders for an application like Facebook, thinking from various viewpoints and how to accomodate each to deliver a satisfactory product.
-> Different types of worlds - problem, solution, design and machine/programming worlds and how proper communication between the associated entities is critical.
-> Why we need to rely more on roles and less on people.
-> Requirements should not be ambiguous.
-> Elicitation, analysis, testing of requirements. How user journeys, wireframes can be used to determine requirements at early stages.
-> Different models for software development - traditional(waterfall) and agile(scrum, DFD etc.) and how agile approaches are modified, improved versions of the classic waterfall model.

Week-5
-> Time-boxing - each task, small or large, should be alloted some deadline under which it should be completed.
-> Learnt in detail about prototypes and how prototypes help in determining problems in the early stages of a project.
-> These prototypes help mitigate risks, identify loopholes and improve overall planning. They also help in the assessment of feasibility of a project.
-> Learnt about evolutionary model, which works on an incremental approach. The project is broken down into smaller modules which can then be independently worked upon.
   This is then iterated over and over again and changes are made accordingly until a version is ready for release.
-> Version control is critical and inevitable for a project today. It gives a bird's eye view of the development journey of the project and helps keep track of major checkpoints.
-> Every project needs to be understood from the points of view of four entities - developer, designer, tester and user.
-> Another prototyping model- the spiral model works in an interesting way. After each cycle of development is completed, project is tested and again repeats the cycle.
-> Learnt about 'Agile Manifesto' and debated over the values and ideals it is based on.
-> How Scrum - an Agile method works - backlogs, burndown charts, daily scrum meetings and strict deadlines.
-> Project management and planning and estimations are critical components of a project.
-> Cone of uncertainty - how unrealistic expectations gradually turn into realistic achievements as a project progresses.
-> Code reuse is directly related to software quality. Identifying the critical qualities and understanding the tradeoffs between various factors is important.
